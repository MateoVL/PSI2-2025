
% Responder preguntas solicitadas:
% 1. ¿Qué dimensiones tienen las matrices del problema?
%       R: las matrices son NxN, multiplicadas por Nx1

% 2. ¿Cómo se obtiene el valor de ⍵?
%       R: aun no lo se

% 3. ¿Qué diferencias tienen las operaciones modulares con las operaciones
%  tradicionales?
%       R: mejor rendimiento en vectores grandes, O(n log(n)) vs O(n^2)

function w = primitive_nth_roots(q, n)
    for i = 2:q-1
        % condition 1: w^n = 1 mod q
        if mod(i^n, q) == 1
            isPrimitive = true;
            % condition 2: w^k not= 1 mod q para k < n
            for k = 1:n-1
                if mod(i^k, q) == 1
                    isPrimitive = false;
                    break;
                end
            end
            if isPrimitive

                w = i;
                return; % guardamos la raíz
            end
        end
    end
end

% 1. make our w, Z, and array
% 2. matrix multiplication for the 2 signals
% 3. element wise vector multipliucation
% 4. get the N^-1 and second matrix multiplication

N = 8;
q = 3329;

% obtener w
w = primitive_nth_roots(q, N);
disp("w: ")
disp(w)


g_before = randi([1, w], 1, N/2);
h_before = randi([1, w], 1, N/2);

g = [randi([1, w], 1, N/2), zeros(1, N/2)];
h = [randi([1, w], 1, N/2), zeros(1, N/2)];




disp('señal g: ')
disp(g)
disp('señal h: ')
disp(h)

N_Padding = length(g) + length(h) - 1;


% multiplicacion matricial NTT
m1 = zeros(N);
% fill the matrix
for i = 0:N-1
    for j = 0:N-1
        % supongo que se hace asi
    m1(i + 1, j + 1) = powermod(w, mod(i*j, N), q);
    end
end
disp("Matriz 1: ")
disp(m1)

% calculate multiplication

g_gorrito = mod(m1 * transpose(g), q);
h_gorrito = mod(m1 * transpose(h), q);

disp("g gorrito: ")
disp(g_gorrito)
disp("h gorrito: ")
disp(h_gorrito)

% Perform element-wise multiplication of the transformed signals
resultG = mod(g_gorrito .* h_gorrito, q);
disp("Matriz resultado de multiplicación por elemento: ")
disp(resultG)


% Inverse NTT of reslutG

% get N^-1, inverso modular de N
N1 = powermod(N, -1, q);
fprintf("N^-1 (Inverso modular de N): %d\n\n", N1)

% second matrix
m2 = zeros(N);
for i = 0:N-1
    for j = 0:N-1
        m2(i +1, j+1) = powermod(w, mod(-i*j, N), q);
    end
end
disp("Matriz 2: ")
disp(m2)

% Perform the inverse NTT multiplication
intt = m2 * resultG;
intt = intt .* N1;
intt = mod(intt, q);

% zero padding of result to get vector of size N + N - 1
intt = [intt', zeros(1, N - 1)];

disp("Resultado de convolución por transformada teorica numerica: ")
fprintf("%d  ", intt);
fprintf("\n");

disp("Resultado de conv(): ")
fprintf("%d  ", conv(g,h))
fprintf("\n");